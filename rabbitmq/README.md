安装：docker load -i mq.tar
运行：
docker run \
-e RABBITMQ_DEFAULT_USER=admin \
-e RABBITMQ_DEFAULT_PASS=123456 \
-v mq-plugins:/plugins \
--name mq \
--hostname mq \
-p 15672:15672 \
-p 5672:5672 \
-d \
rabbitmq:3.8-management

然后浏览器打开http://127.0.0.1:15672

1.消息堆积
提高消费者的消费能力，使用多线程消费任务
增加更多消费者，设置多个消费者消费同一个队列，提高消费速度
扩大队列容量，提高堆积上限
使用惰性队列lazyQueue，将消息储存到磁盘
设置prefetch配置控制消息预取的数量，处理完一条再取下一条，避免堆积在消费者里

2.交换机的作用是什么
接收publisher发送的消息
将消息按照规则路由到与它绑定的队列
FanoutExchange交换机会将消息路由到每个绑定的队列
publisher向交换机发送消息后，交换机会把这条消息发送到所有与它绑定的队列中

3.fanout、direct、topic交换机的区别是什么
使用bind绑定队列时，fanout只能路由到指定的队列里，而direct可以根据routing key指定路由到哪个队列，而topic则可以使用通配符指定多个队列，例如test.#、*.test，#表示匹配0个或多个单词，比如可以匹配到test.test1.test2，*表示匹配一个单词

4.Spring AMQP常用bean
RabbitTemplate：操作rabbitMQ信息的比如发送信息
FanoutExchange/DirectExchange/TopicExchange：声明交换机的
Queue：声明队列的
Binding：绑定交换机和队列的

5.Spring AMQP常用注解
@RabbitListener：监听rabbitmq的注解
@QueueBinding：绑定rabbit交换机和队列的注解
@Queue：指定队列名称
@Exchange：指定交换机名称

6.如何保证消息不丢失
第一是开启生产者确认机制，确保消息能够到达队列，如果有报错的话（返回NACK）也可以记录起来，再去做相应的处理比如修复数据、重发等等
第二是开启持久化功能，把消息持久化到磁盘当中，确保消息在队列中的时候不会因为宕机等问题导致消息丢失，在新版的rabbitMQ的LazyQueue（就是没条消息都会持久化到磁盘）就挺好的，解决这个问题
第三是开启消费者确认机制，就是消费者失败的话会给队列返回NACK，队列会重新给消费者投递，当然也要设置好重试的次数

7.重复消费问题
如果消费者在处理完业务之后，在给MQ发送确认的ACK之前出了问题，比如宕机了，就导致MQ没有删除掉信息，就会被消费者重复消费了，解决重复消费的问题，主要是保证业务的幂等性（幂等性是一个数学概念，意思是无论执行多少次，结果都不会变，比如取绝对值，2的绝对值就是2，无论取多少次绝对值都是2），就不怕重复消费了，也就是说就算重复消费了也不会有什么影响，结合具体的业务逻辑判断是否已经执行过了，不要去重复执行就行了，比如我之前做的OA系统，给员工发公告，有个公告id关联员工id的业务，那我在队列消费的时候，查询一下关联表里面是否已存在数据，如果存在就不继续往下走了，这样的话即使重复消费也没事了，第二种方法就是把消息id保存起来，查询到有这个id的话就不继续往下走了

8.什么是死信交换机
如果消息未被消费，就会去到死信交换机中，比如消费者确认机制的时候返回了reject、NACK，或者队列没有绑定消费者，消息过期了没有被消费，就会去到死信交换机，我们可以用死信交换机的这个逻辑实现延迟消息，原理是给消息设置一个TTL，发送到一个没有消费者的队列，并且这个队列用dead-letter-exchange绑定了死信交换机，等这个消息的TTL过了，就会去到这个死信交换机，这个交换机又绑定了一个有消费者的队列，然后就会被消费了，另外可以使用延迟消息插件实现延时队列

